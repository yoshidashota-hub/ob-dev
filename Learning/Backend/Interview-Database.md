# データベース - 技術面接対策

## 概要

データベースの基礎知識。インデックス、トランザクション、ロック、パフォーマンスチューニングなど。

---

## 1. DB のレスポンスが遅い時の調査方法

### 調査手順

1. **スロークエリログ**で遅いクエリを特定

   - PostgreSQL: `pg_stat_statements`
   - MySQL: `slow_query_log`

2. **EXPLAIN ANALYZE** で実行計画を確認

   - Seq Scan の有無
   - 想定外の JOIN
   - 行数見積もりの乖離

3. **インデックス**の確認

   - 複合インデックスの順序
   - カーディナリティ

4. **N+1 問題**の検出

   - Rails なら `bullet` gem
   - ORM のログを確認

5. **インフラ面**

   - コネクションプール
   - メモリ設定
   - ディスク I/O

6. **APM ツール**
   - Datadog、New Relic でボトルネック可視化

---

## 2. インデックス

### インデックスが効かないケース

| ケース             | 説明                            |
| ------------------ | ------------------------------- |
| `LIKE '%xxx'`      | 前方一致以外                    |
| カラムに関数適用   | `WHERE YEAR(created_at) = 2024` |
| 型の暗黙変換       | 文字列と数値の比較              |
| 低カーディナリティ | 性別などデータの種類が少ない    |
| フルスキャンが速い | オプティマイザの判断            |

### 複合インデックスの順序

```sql
-- WHERE a = 1 AND b = 2 の場合
CREATE INDEX idx_a_b ON table (a, b);  -- ○ 効く
CREATE INDEX idx_b_a ON table (b, a);  -- △ aだけなら効かない

-- 左端から順に使われる（最左マッチの法則）
```

---

## 3. ロック

### 楽観的ロック vs 悲観的ロック

| 項目               | 楽観的ロック             | 悲観的ロック        |
| ------------------ | ------------------------ | ------------------- |
| 方式               | バージョン番号で競合検出 | `SELECT FOR UPDATE` |
| チェックタイミング | コミット時               | 取得時              |
| 適用場面           | 競合少ない場合           | 競合多い場合        |
| 問題点             | 更新失敗のリトライ必要   | デッドロック注意    |

```sql
-- 楽観的ロック
UPDATE users SET name = 'new', version = version + 1
WHERE id = 1 AND version = 5;

-- 悲観的ロック
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```

---

## 4. RDB vs NoSQL

| 項目     | RDB                      | NoSQL                      |
| -------- | ------------------------ | -------------------------- |
| 整合性   | ACID 保証                | 結果整合性が多い           |
| スキーマ | 固定                     | 柔軟                       |
| スケール | 垂直スケール中心         | 水平スケール容易           |
| JOIN     | 得意                     | 苦手                       |
| 用途     | 複雑なクエリ、整合性重視 | 高スループット、大量データ |

### 使い分け

- **RDB**: ACID 必須、複雑な結合、スキーマの整合性重視
- **NoSQL**: スキーマ柔軟性、水平スケール、結合不要なデータ

---

## 5. N+1 問題

### 問題

```tsx
// 1回のクエリで親データを取得
const users = await db.user.findMany(); // 1クエリ

// N回のクエリで関連データを取得
for (const user of users) {
  const posts = await db.post.findMany({ where: { userId: user.id } }); // N回
}
```

### 解決策

```tsx
// Eager Loading
const users = await db.user.findMany({
  include: { posts: true }, // 1+1 クエリ
});

// GraphQL なら DataLoader でバッチ処理
```

---

## 6. トランザクション分離レベル

| 分離レベル       | Dirty Read | Non-repeatable Read | Phantom Read |
| ---------------- | ---------- | ------------------- | ------------ |
| Read Uncommitted | 発生       | 発生                | 発生         |
| Read Committed   | 防止       | 発生                | 発生         |
| Repeatable Read  | 防止       | 防止                | 発生         |
| Serializable     | 防止       | 防止                | 防止         |

### デフォルト

- **PostgreSQL**: Read Committed
- **MySQL InnoDB**: Repeatable Read

### 各問題の説明

| 問題                | 説明                     |
| ------------------- | ------------------------ |
| Dirty Read          | コミット前のデータを読む |
| Non-repeatable Read | 同じクエリで異なる結果   |
| Phantom Read        | 同じ条件で行数が変わる   |

---

## 7. MVCC（Multi-Version Concurrency Control）

### 仕組み

- 読み取りがロックを取らずにスナップショットを参照
- PostgreSQL: xmin/xmax で行のバージョン管理
- バキュームで古いバージョンを回収

### メリット

- 読み取りと書き込みが互いをブロックしない
- 高い並行性

---

## 8. シャーディング

### 戦略

| 戦略      | 説明                   | 特徴                         |
| --------- | ---------------------- | ---------------------------- |
| Range     | 範囲で分割（日付など） | ホットスポットになりやすい   |
| Hash      | ハッシュ値で分散       | 均等だがレンジクエリが難しい |
| Directory | 対応表で管理           | 柔軟だが複雑                 |

### 注意点

- クロスシャードクエリの難しさ
- リシャーディングのコスト
- 分散トランザクション

---

## 9. レプリケーション

### 同期 vs 非同期

| 項目       | 同期                           | 非同期                         |
| ---------- | ------------------------------ | ------------------------------ |
| 整合性     | 強整合性                       | 結果整合性                     |
| 可用性     | レプリカ障害で書き込みブロック | 高い                           |
| データロス | なし                           | フェイルオーバー時に可能性あり |
| レイテンシ | 高い                           | 低い                           |

---

## 10. DB マイグレーション

### 気をつけること

- [ ] ロック時間の最小化（大規模テーブルの ALTER）
- [ ] 後方互換性（新旧コードが共存する期間）
- [ ] 段階的デプロイ
  1. カラム追加
  2. コード変更
  3. 旧カラム削除
- [ ] ロールバック戦略

### 大規模テーブルの ALTER

```sql
-- 悪い例：テーブルロック発生
ALTER TABLE huge_table ADD COLUMN new_col VARCHAR(255);

-- 良い例：pt-online-schema-change や gh-ost を使用
```

---

## 11. EXPLAIN の読み方

### ポイント

| 項目       | 説明                   |
| ---------- | ---------------------- |
| コスト     | 相対的な処理コスト     |
| 実行順序   | 内側から外側へ         |
| Seq Scan   | フルスキャン（要注意） |
| Index Scan | インデックス利用       |

### 結合方式

| 方式        | 適用場面         |
| ----------- | ---------------- |
| Nested Loop | 小さいテーブル   |
| Hash Join   | 等価結合         |
| Merge Join  | ソート済みデータ |

---

## 12. 検索・Elasticsearch

### 全文検索の仕組み

1. **転置インデックス**: 単語 → 文書 ID のマッピング
2. **トークナイズ**: テキストを単語に分割
3. **アナライザー**: 正規化、ステミング
4. **スコアリング**: TF-IDF、BM25

### RDB の LIKE 検索との違い

| 項目             | RDB LIKE              | Elasticsearch                        |
| ---------------- | --------------------- | ------------------------------------ |
| インデックス効率 | `LIKE '%xxx%'` は遅い | 高速                                 |
| スケーラビリティ | 限定的                | 分散前提                             |
| 機能             | 基本的                | あいまい検索、ファセット、ハイライト |

---

## 学習チェックリスト

### 基本

- [ ] インデックスが効かないケースを説明できる
- [ ] 楽観的ロックと悲観的ロックの違いを説明できる
- [ ] N+1 問題と解決策を説明できる

### トランザクション

- [ ] 分離レベルと各問題を説明できる
- [ ] MVCC の仕組みを説明できる

### スケーリング

- [ ] シャーディング戦略を説明できる
- [ ] レプリケーションの同期/非同期を説明できる

### パフォーマンス

- [ ] EXPLAIN の読み方を説明できる
- [ ] スロークエリの調査方法を説明できる

---

## 関連ノート

- [[Interview-Backend-API]]
- [[Interview-Distributed-Systems]]
- [[Interview-CS-Fundamentals]]
