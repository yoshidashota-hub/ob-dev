# アーキテクチャ選択ガイド

## アーキテクチャパターン一覧

```
┌─────────────────────────────────────────────────────────────────┐
│                 アーキテクチャパターン                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  モノリス                                                       │
│  ├── シンプルモノリス    - 単一アプリ                          │
│  └── モジュラーモノリス  - 内部モジュール分割                  │
│                                                                 │
│  分散システム                                                   │
│  ├── マイクロサービス    - サービス分割                        │
│  ├── イベント駆動        - 非同期メッセージング                │
│  └── サーバーレス        - FaaS ベース                         │
│                                                                 │
│  レイヤードアーキテクチャ                                       │
│  ├── MVC / MVP / MVVM    - UI パターン                         │
│  ├── クリーンアーキテクチャ - 依存性逆転                       │
│  ├── ヘキサゴナル        - ポート＆アダプター                  │
│  └── オニオン            - ドメイン中心                        │
│                                                                 │
│  データ指向                                                     │
│  ├── CQRS               - コマンド/クエリ分離                  │
│  └── イベントソーシング  - イベント履歴                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 選択フローチャート

```
┌─────────────────────────────────────────┐
│        どのアーキテクチャを選ぶ？        │
└─────────────────────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │                       │
        ▼                       ▼
    チーム規模は？          システム規模は？
        │                       │
   ┌────┴────┐             ┌────┴────┐
   ▼         ▼             ▼         ▼
 小規模    大規模        小〜中     大規模
(1-5人)   (10人+)                 複雑
   │         │             │         │
   ▼         ▼             ▼         ▼
モノリス  マイクロ     モノリス   分散
         サービス     (モジュラー) システム
```

## プロジェクト規模別おすすめ

### 個人開発 / MVP

```
推奨: シンプルモノリス
├── フレームワーク: Next.js / Rails / Laravel
├── DB: 単一データベース
├── デプロイ: Vercel / Railway
└── 期間: 数週間〜数ヶ月

理由:
✓ 素早く市場投入
✓ 運用シンプル
✓ 後から分割可能
```

### スタートアップ（初期）

```
推奨: モジュラーモノリス
├── 内部でモジュール分割
├── 将来の分割を見据えた設計
├── チーム: 3-10人
└── 期間: 1-2年

理由:
✓ 開発速度を維持
✓ 技術的負債を抑制
✓ マイクロサービスへの移行パス
```

### スタートアップ（成長期）/ 中規模

```
推奨: マイクロサービス（段階的）
├── コアドメインから分離
├── チーム: 10-50人
├── 複数チームで並行開発
└── CI/CD パイプライン整備

注意:
⚠ 早すぎる分割は避ける
⚠ 分散システムの複雑さを理解
```

### エンタープライズ / 大規模

```
推奨: マイクロサービス + イベント駆動
├── ドメイン境界でサービス分割
├── 非同期メッセージング
├── チーム: 50人+
├── 専門 SRE / Platform チーム

構成:
├── API Gateway
├── Service Mesh
├── イベントバス (Kafka / SQS)
└── 分散トレーシング
```

## アーキテクチャパターン詳細

### モノリス vs マイクロサービス

```
┌─────────────────────────────────────────────────────────────┐
│                      モノリス                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    ┌─────────────────────────────────────────┐             │
│    │              単一アプリケーション        │             │
│    │  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐   │             │
│    │  │User │  │Order│  │Pay  │  │Ship │   │             │
│    │  └─────┘  └─────┘  └─────┘  └─────┘   │             │
│    │           共有データベース              │             │
│    └─────────────────────────────────────────┘             │
│                                                             │
│  メリット:                                                  │
│  ✓ シンプル、デプロイ容易                                  │
│  ✓ トランザクション容易                                    │
│  ✓ デバッグしやすい                                        │
│                                                             │
│  デメリット:                                                │
│  ✗ スケールが全体単位                                      │
│  ✗ 技術スタック固定                                        │
│  ✗ チーム間の衝突                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                   マイクロサービス                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐                 │
│  │User │    │Order│    │Pay  │    │Ship │                 │
│  │ API │    │ API │    │ API │    │ API │                 │
│  └──┬──┘    └──┬──┘    └──┬──┘    └──┬──┘                 │
│     │          │          │          │                     │
│  ┌──┴──┐    ┌──┴──┐    ┌──┴──┐    ┌──┴──┐                 │
│  │ DB  │    │ DB  │    │ DB  │    │ DB  │                 │
│  └─────┘    └─────┘    └─────┘    └─────┘                 │
│                                                             │
│  メリット:                                                  │
│  ✓ 独立スケール                                            │
│  ✓ 技術選択の自由                                          │
│  ✓ チーム自律性                                            │
│                                                             │
│  デメリット:                                                │
│  ✗ 運用複雑                                                │
│  ✗ 分散トランザクション                                    │
│  ✗ ネットワーク障害                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

| 観点               | モノリス | マイクロサービス |
| ------------------ | -------- | ---------------- |
| 開発速度（初期）   | 速い     | 遅い             |
| 開発速度（成長後） | 遅くなる | 維持できる       |
| デプロイ           | 全体一括 | 個別             |
| スケーラビリティ   | 垂直     | 水平             |
| 障害影響           | 全体     | 局所             |
| チーム構成         | 機能横断 | サービス単位     |
| 運用コスト         | 低い     | 高い             |

### モジュラーモノリス

```
┌─────────────────────────────────────────────────────────────┐
│                   モジュラーモノリス                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│    ┌─────────────────────────────────────────┐             │
│    │           単一デプロイメント             │             │
│    │                                         │             │
│    │  ┌─────────┐  ┌─────────┐  ┌─────────┐ │             │
│    │  │  User   │  │  Order  │  │ Payment │ │             │
│    │  │ Module  │  │ Module  │  │ Module  │ │             │
│    │  │         │  │         │  │         │ │             │
│    │  │ ┌─────┐ │  │ ┌─────┐ │  │ ┌─────┐ │ │             │
│    │  │ │ API │ │  │ │ API │ │  │ │ API │ │ │             │
│    │  │ │Logic│ │  │ │Logic│ │  │ │Logic│ │ │             │
│    │  │ │ DB  │ │  │ │ DB  │ │  │ │ DB  │ │ │             │
│    │  │ └─────┘ │  │ └─────┘ │  │ └─────┘ │ │             │
│    │  └────┬────┘  └────┬────┘  └────┬────┘ │             │
│    │       │            │            │       │             │
│    │       └────────────┼────────────┘       │             │
│    │                    │                    │             │
│    │            明確な境界・API              │             │
│    └─────────────────────────────────────────┘             │
│                                                             │
│  特徴:                                                      │
│  ✓ モノリスの利点を維持                                    │
│  ✓ モジュール間は明確なインターフェース                    │
│  ✓ 将来のサービス分割が容易                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```typescript
// モジュラーモノリスの構造例
src/
├── modules/
│   ├── user/
│   │   ├── api/           # 公開 API
│   │   │   └── UserApi.ts
│   │   ├── domain/        # ドメインロジック
│   │   │   ├── User.ts
│   │   │   └── UserService.ts
│   │   ├── infra/         # インフラ
│   │   │   └── UserRepository.ts
│   │   └── index.ts       # 公開エクスポート
│   │
│   ├── order/
│   │   ├── api/
│   │   ├── domain/
│   │   ├── infra/
│   │   └── index.ts
│   │
│   └── payment/
│       └── ...
│
├── shared/                # 共有コード（最小限に）
│   ├── kernel/
│   └── utils/
│
└── main.ts

// モジュール間通信
// ❌ 直接参照
import { User } from '../user/domain/User';

// ✓ 公開 API 経由
import { UserApi } from '../user';
const user = await UserApi.getUser(userId);
```

### クリーンアーキテクチャ / ヘキサゴナル

```
┌─────────────────────────────────────────────────────────────┐
│                  クリーンアーキテクチャ                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│         ┌─────────────────────────────────────┐            │
│         │         Frameworks & Drivers        │            │
│         │  (Web, DB, External Services)       │            │
│         │     ┌─────────────────────────┐     │            │
│         │     │    Interface Adapters   │     │            │
│         │     │  (Controllers, Gateways)│     │            │
│         │     │   ┌─────────────────┐   │     │            │
│         │     │   │   Use Cases     │   │     │            │
│         │     │   │  (Application)  │   │     │            │
│         │     │   │  ┌───────────┐  │   │     │            │
│         │     │   │  │  Domain   │  │   │     │            │
│         │     │   │  │ Entities  │  │   │     │            │
│         │     │   │  └───────────┘  │   │     │            │
│         │     │   └─────────────────┘   │     │            │
│         │     └─────────────────────────┘     │            │
│         └─────────────────────────────────────┘            │
│                                                             │
│  依存性の方向: 外側 → 内側                                  │
│  内側は外側を知らない                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```typescript
// クリーンアーキテクチャの例

// Domain Layer（最も内側）
// domain/entities/Order.ts
class Order {
  constructor(
    public readonly id: string,
    public readonly items: OrderItem[],
    public status: OrderStatus,
  ) {}

  complete() {
    if (this.status !== "pending") {
      throw new Error("Cannot complete");
    }
    this.status = "completed";
  }
}

// domain/repositories/OrderRepository.ts（インターフェース）
interface OrderRepository {
  findById(id: string): Promise<Order | null>;
  save(order: Order): Promise<void>;
}

// Application Layer（Use Cases）
// application/usecases/CompleteOrderUseCase.ts
class CompleteOrderUseCase {
  constructor(
    private orderRepository: OrderRepository,
    private notificationService: NotificationService,
  ) {}

  async execute(orderId: string): Promise<void> {
    const order = await this.orderRepository.findById(orderId);
    if (!order) throw new Error("Order not found");

    order.complete();

    await this.orderRepository.save(order);
    await this.notificationService.notifyOrderCompleted(order);
  }
}

// Infrastructure Layer（最も外側）
// infra/repositories/PrismaOrderRepository.ts
class PrismaOrderRepository implements OrderRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(id: string): Promise<Order | null> {
    const data = await this.prisma.order.findUnique({ where: { id } });
    return data ? this.toEntity(data) : null;
  }

  async save(order: Order): Promise<void> {
    await this.prisma.order.update({
      where: { id: order.id },
      data: this.toData(order),
    });
  }
}
```

**いつ使うか:**

| 条件                   | クリーンアーキテクチャ |
| ---------------------- | ---------------------- |
| ドメインロジックが複雑 | ✓ 推奨                 |
| 長期保守が必要         | ✓ 推奨                 |
| テスト容易性が重要     | ✓ 推奨                 |
| シンプルな CRUD        | ✗ 過剰                 |
| MVP / プロトタイプ     | ✗ 過剰                 |

### CQRS（Command Query Responsibility Segregation）

```
┌─────────────────────────────────────────────────────────────┐
│                         CQRS                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐          ┌─────────────────┐          │
│  │    Command      │          │     Query       │          │
│  │   (書き込み)    │          │   (読み取り)    │          │
│  └────────┬────────┘          └────────┬────────┘          │
│           │                            │                    │
│           ▼                            ▼                    │
│  ┌─────────────────┐          ┌─────────────────┐          │
│  │  Command Model  │          │   Query Model   │          │
│  │  (正規化)       │  ──同期→ │  (非正規化)     │          │
│  └────────┬────────┘          └────────┬────────┘          │
│           │                            │                    │
│           ▼                            ▼                    │
│  ┌─────────────────┐          ┌─────────────────┐          │
│  │   Write DB      │          │    Read DB      │          │
│  │  (PostgreSQL)   │          │ (Elasticsearch) │          │
│  └─────────────────┘          └─────────────────┘          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```typescript
// CQRS の例

// Command（書き込み）
class CreateOrderCommand {
  constructor(
    public readonly userId: string,
    public readonly items: { productId: string; quantity: number }[],
  ) {}
}

class CreateOrderHandler {
  async handle(command: CreateOrderCommand): Promise<string> {
    // 複雑なビジネスロジック
    const order = Order.create(command.userId, command.items);
    await this.orderRepository.save(order);

    // イベント発行（Read モデル更新用）
    await this.eventBus.publish(new OrderCreatedEvent(order));

    return order.id;
  }
}

// Query（読み取り）
class GetOrdersQuery {
  constructor(
    public readonly userId: string,
    public readonly status?: string,
  ) {}
}

class GetOrdersHandler {
  async handle(query: GetOrdersQuery): Promise<OrderDto[]> {
    // 非正規化された Read モデルから高速取得
    return this.orderReadRepository.findByUser(query.userId, query.status);
  }
}
```

**いつ使うか:**

| 条件                         | CQRS |
| ---------------------------- | ---- |
| 読み書きの負荷が大きく異なる | ✓    |
| 複雑な検索要件               | ✓    |
| 読み取りのスケールが必要     | ✓    |
| シンプルな CRUD              | ✗    |
| データ整合性が最重要         | ✗    |

### イベント駆動アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                   イベント駆動                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐                              ┌─────────┐      │
│  │ Order   │  ── OrderCreated ──────────→ │Inventory│      │
│  │ Service │                              │ Service │      │
│  └─────────┘           │                  └─────────┘      │
│                        │                                    │
│                        ▼                                    │
│               ┌─────────────────┐                          │
│               │   Event Bus     │                          │
│               │ (Kafka / SQS)   │                          │
│               └─────────────────┘                          │
│                        │                                    │
│           ┌────────────┼────────────┐                      │
│           ▼            ▼            ▼                      │
│     ┌─────────┐  ┌─────────┐  ┌─────────┐                 │
│     │Shipping │  │ Payment │  │ Email   │                 │
│     │ Service │  │ Service │  │ Service │                 │
│     └─────────┘  └─────────┘  └─────────┘                 │
│                                                             │
│  特徴:                                                      │
│  ✓ 疎結合                                                  │
│  ✓ スケーラブル                                            │
│  ✓ 耐障害性                                                │
│  ✗ 結果整合性（即時整合性ではない）                        │
│  ✗ デバッグが複雑                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## ユースケース別選択

### E コマース

```
規模別:

小規模（月商100万以下）
└─→ シンプルモノリス（Next.js + Prisma）

中規模（月商1億以下）
└─→ モジュラーモノリス
    ├── User Module
    ├── Product Module
    ├── Order Module
    └── Payment Module

大規模（月商1億超）
└─→ マイクロサービス + イベント駆動
    ├── User Service
    ├── Catalog Service
    ├── Order Service (CQRS)
    ├── Payment Service
    ├── Inventory Service
    └── Notification Service
```

### SaaS

```
初期（PMF 前）
└─→ シンプルモノリス
    - 機能追加・変更が頻繁
    - 素早くピボット

成長期（PMF 後）
└─→ モジュラーモノリス
    ├── Tenant Module（マルチテナント）
    ├── Billing Module
    ├── Core Feature Modules
    └── Integration Module

成熟期
└─→ マイクロサービス（必要な部分のみ）
    - 高負荷部分を分離
    - チーム自律性確保
```

### リアルタイムアプリ（チャット等）

```
推奨: イベント駆動 + CQRS

┌──────────────┐
│   Client     │
└──────┬───────┘
       │ WebSocket
       ▼
┌──────────────┐
│  Gateway     │
│  (Socket.io) │
└──────┬───────┘
       │
       ▼
┌──────────────────────────────────┐
│          Event Bus (Redis)       │
└──────────────────────────────────┘
       │
  ┌────┴────┬────────┐
  ▼         ▼        ▼
┌─────┐  ┌─────┐  ┌─────┐
│Chat │  │Notif│  │Pres-│
│Svc  │  │Svc  │  │ence │
└─────┘  └─────┘  └─────┘
```

## アンチパターン

### 1. 早すぎるマイクロサービス化

```
❌ 問題:
- チーム3人でマイクロサービス
- ドメイン境界が不明確なまま分割
- 運用コストが開発を圧迫

✓ 対策:
- まずモノリスで始める
- ドメインが明確になってから分割
- 痛みを感じてから対処
```

### 2. 分散モノリス

```
❌ 問題:
- マイクロサービスだが密結合
- 全サービス同時デプロイが必要
- 分散システムのデメリットだけ

✓ 対策:
- サービス間は API 契約で疎結合
- 共有 DB を避ける
- 非同期通信を活用
```

### 3. 過剰なレイヤー

```
❌ 問題:
- CRUD アプリにクリーンアーキテクチャ
- 全ての操作が複数レイヤーを通過
- 開発速度が低下

✓ 対策:
- 複雑さに応じてレイヤーを選択
- シンプルな CRUD は直接実装
- 重要なドメインロジックのみ分離
```

## 選択チェックリスト

### モノリスで十分か？

```
□ チームは10人以下か？
□ 単一の技術スタックで問題ないか？
□ 全体のスケールで足りるか？
□ デプロイ頻度は週1-2回で十分か？

→ 全て YES ならモノリス推奨
```

### マイクロサービスが必要か？

```
□ チームが10人以上で、独立して動きたい？
□ サービスごとに異なるスケールが必要？
□ 異なる技術スタックが必要？
□ 運用チーム（SRE）がいる？

→ 複数 YES ならマイクロサービス検討
```

### クリーンアーキテクチャが必要か？

```
□ ドメインロジックが複雑か？
□ ビジネスルールが頻繁に変わるか？
□ 長期（3年以上）保守が予想されるか？
□ テストカバレッジが重要か？

→ 複数 YES ならクリーンアーキテクチャ検討
```

## まとめ

### 選択早見表

| 状況                   | 推奨アーキテクチャ             |
| ---------------------- | ------------------------------ |
| MVP / 個人開発         | シンプルモノリス               |
| スタートアップ（初期） | モノリス → モジュラーモノリス  |
| 中規模（10-50人）      | モジュラーモノリス or 部分分割 |
| 大規模（50人+）        | マイクロサービス               |
| 複雑なドメイン         | クリーンアーキテクチャ         |
| 読み書き負荷差が大     | CQRS                           |
| 非同期処理が多い       | イベント駆動                   |

### 現実的なアプローチ

```
1. モノリスで始める（ほぼ全てのケース）
2. モジュール境界を意識した設計
3. 痛みを感じたら段階的に分割
4. 分割は最も独立性の高い部分から
```

## 関連

- [サーバーレス vs サーバー構成](./Serverless-vs-Server.md)
- [データベース選択ガイド](../DB/Database-Selection-Guide.md)
- [クリーンアーキテクチャ](./CleanArchitecture.md)
- [マイクロサービス](./Microservices.md)
- [イベント駆動アーキテクチャ](./EventDrivenArchitecture.md)
