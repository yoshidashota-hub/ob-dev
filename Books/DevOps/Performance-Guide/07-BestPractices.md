# 第7章: ベストプラクティス

## パフォーマンスバジェット

```typescript
// performance-budget.ts
export const performanceBudget = {
  // Core Web Vitals
  webVitals: {
    lcp: 2500, // ms
    inp: 200, // ms
    cls: 0.1,
    fcp: 1800, // ms
    ttfb: 800, // ms
  },

  // バンドルサイズ (gzip)
  bundle: {
    javascript: 300, // KB
    css: 50, // KB
    total: 1000, // KB
    perRoute: 150, // KB（ルートごと）
  },

  // API パフォーマンス
  api: {
    p50: 100, // ms
    p95: 300, // ms
    p99: 1000, // ms
    errorRate: 0.01, // 1%
  },

  // データベース
  database: {
    queryTime: 50, // ms
    connectionTime: 100, // ms
  },
};
```

## チェックリスト

### フロントエンド

```
□ Core Web Vitals が目標値を達成している
  □ LCP ≤ 2.5s
  □ INP ≤ 200ms
  □ CLS ≤ 0.1

□ バンドルサイズを最適化
  □ 動的インポートを活用
  □ Tree Shaking が機能している
  □ 不要な依存関係を削除

□ 画像を最適化
  □ Next.js Image を使用
  □ 適切なフォーマット（WebP/AVIF）
  □ lazy loading を設定
  □ LCP 対象は priority を設定

□ レンダリングを最適化
  □ 適切なコンポーネントをメモ化
  □ 大量リストは仮想化
  □ Server Components を活用

□ レイアウトシフトを防止
  □ 画像にサイズを指定
  □ フォントの display: swap
  □ スケルトン UI を使用
```

### バックエンド

```
□ API レスポンスを最適化
  □ 圧縮を有効化
  □ ページネーションを実装
  □ 必要なフィールドのみ返す

□ N+1 問題を解決
  □ Include/Join で一括取得
  □ DataLoader パターンを使用

□ キャッシュを活用
  □ 適切な TTL を設定
  □ キャッシュ無効化ロジックを実装
  □ Redis/ElastiCache を検討

□ 非同期処理を活用
  □ 重い処理はキューに投入
  □ バックグラウンドジョブで処理

□ コネクション管理
  □ コネクションプールを設定
  □ Lambda でのコネクション再利用
```

### データベース

```
□ クエリを最適化
  □ EXPLAIN ANALYZE で実行計画確認
  □ 遅いクエリを特定・改善

□ インデックスを最適化
  □ 頻繁なクエリにインデックス
  □ 複合インデックスの順序を検討
  □ 不要なインデックスを削除

□ バッチ処理を活用
  □ 一括挿入/更新を使用
  □ ループ内でのクエリを避ける

□ DynamoDB 固有
  □ パーティション設計を最適化
  □ Scan ではなく Query を使用
  □ プロジェクションで必要な属性のみ
```

### インフラ

```
□ CDN を活用
  □ 静的アセットをキャッシュ
  □ 適切なキャッシュヘッダーを設定
  □ 圧縮を有効化

□ Lambda を最適化
  □ 適切なメモリサイズ
  □ コールドスタート対策
  □ ARM64 アーキテクチャを検討

□ キャッシュ層を設置
  □ ElastiCache/Redis を活用
  □ DAX を検討（DynamoDB）

□ ネットワークを最適化
  □ VPC エンドポイントを設定
  □ 同一 AZ 内通信を優先
```

## パフォーマンス改善フロー

```
┌────────────────────────────────────────────────────────────┐
│                    改善プロセス                              │
│                                                            │
│  1. 計測                                                    │
│     └─ Lighthouse, RUM, APM で現状把握                     │
│                                                            │
│  2. 分析                                                    │
│     └─ ボトルネックを特定                                   │
│     └─ 優先度を決定（影響度 × 改善容易性）                  │
│                                                            │
│  3. 仮説                                                    │
│     └─ 改善策を立案                                         │
│     └─ 期待される効果を見積もる                             │
│                                                            │
│  4. 実装                                                    │
│     └─ 小さな変更から始める                                 │
│     └─ A/B テストを検討                                     │
│                                                            │
│  5. 検証                                                    │
│     └─ 効果を測定                                           │
│     └─ 副作用がないか確認                                   │
│                                                            │
│  6. 文書化                                                  │
│     └─ 変更内容と効果を記録                                 │
│     └─ ナレッジを共有                                       │
└────────────────────────────────────────────────────────────┘
```

## 優先度の決め方

```
┌────────────────────────────────────────────────────────────┐
│              パフォーマンス改善の優先度                       │
│                                                            │
│  高優先度:                                                  │
│  • Core Web Vitals が「Poor」の項目                         │
│  • ユーザー離脱に直結する問題                                │
│  • SEO に影響するページ                                     │
│                                                            │
│  中優先度:                                                  │
│  • Core Web Vitals が「Needs Improvement」                  │
│  • コスト削減につながる最適化                                │
│  • 開発効率に影響する問題                                   │
│                                                            │
│  低優先度:                                                  │
│  • 既に「Good」だがさらに改善可能                            │
│  • 影響範囲が限定的な改善                                   │
│  • 技術的負債の解消                                         │
└────────────────────────────────────────────────────────────┘
```

## アンチパターン

```
❌ 避けるべきこと:

1. 計測なしの最適化
   └─ 「多分遅い」で改善しない
   └─ 必ずデータに基づいて判断

2. 早すぎる最適化
   └─ 問題になる前に複雑な最適化をしない
   └─ シンプルな実装から始める

3. 一度に大きな変更
   └─ 効果測定が困難になる
   └─ 小さな変更を積み重ねる

4. キャッシュの乱用
   └─ 無効化ロジックの欠如
   └─ 古いデータを返すリスク

5. 数値の追求のみ
   └─ ユーザー体験を忘れない
   └─ 体感速度も重要
```

## 参考リンク

- [web.dev/performance](https://web.dev/performance/)
- [Next.js Performance](https://nextjs.org/docs/pages/building-your-application/optimizing)
- [AWS Performance Efficiency Pillar](https://docs.aws.amazon.com/wellarchitected/latest/performance-efficiency-pillar/)
- [Lighthouse](https://developer.chrome.com/docs/lighthouse/)
